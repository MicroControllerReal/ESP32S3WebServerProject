/* If you need to add additional file systems to file manager (such as the deprecated SPIFFS or a PSRAM drive, etc.)
 * you will need to add them into the test below (right after #if(UseFileManager)
 * and the definition of fmFS[], and function fsBytes();
 */

#if(UseFileManager)

#if(!(SDType == TypeSD || SDType == TypeMMC || UseLittleFS))
  #error No File System Available for File Manager Use         // If neither SD nor LittleFS is being used, you will get compile errors
#endif                                                         // trying to use the File Manager!

// Variables used in File Manager to get the proper file system(s) (LittleFS, SD)
typedef struct {char name[10]; FS fileSys;} FMfsElem;          // A structure to hold a name and a file system such as SD or LittleFS

FMfsElem fmFS[] = {                                            // Array fmFS holds all available file systems
  #if((SDType == TypeSD || SDType == TypeMMC))
    {"SD", SD}                                                 // Such as SD (for SD or MMC cards)
    #if(UseLittleFS)
      ,
    #endif
  #endif
  #if(UseLittleFS)
    {"LittleFS", LittleFS}                                     // And/Or LittleFS
  #endif
};

const int numFS = sizeof(fmFS) / sizeof(FMfsElem);

#if embedFileman
  // Embedded, gzipped version of fileman.htm allows easy initial uploading of files to mass storage
  // Note that if embedFileman is true, the FilAdminHTM setting in customize.h will be ignored!
  const uint8_t fileman_htm_gz[] PROGMEM = {
  0x1F,0x8B,0x08,0x08,0xB6,0x91,0xCB,0x66,0x04,0x00,0x66,0x69,0x6C,0x65,0x6D,0x61,0x6E,0x2E,0x68,0x74,
  0x6D,0x00,0xB5,0x19,0x5D,0x6F,0xDB,0x36,0xF0,0x7D,0xC0,0xFE,0x83,0xCB,0x61,0xAD,0x34,0x2B,0xFE,0x48,
  0xD6,0x6E,0xB3,0x2C,0x03,0x4B,0xD2,0x60,0x19,0xD6,0xA6,0x58,0x52,0x0C,0x43,0xDB,0x07,0x59,0xA2,0x6D,
  0x2E,0xB2,0xA8,0x89,0x74,0x1C,0x57,0xCD,0x7F,0xDF,0xDD,0x91,0xFA,0xB2,0x1D,0xA7,0x2F,0x6B,0x11,0x89,
  0x3A,0x1E,0xEF,0xFB,0x8E,0x47,0x7A,0xFC,0xEC,0xFC,0xEA,0xEC,0xE6,0xEF,0x77,0xAF,0x3B,0xBF,0xDD,0xBC,
  0xF9,0x63,0x32,0x5E,0xE8,0x65,0x02,0x4F,0x1E,0xC6,0x93,0xB1,0x16,0x3A,0xE1,0x93,0x71,0xDF,0xBC,0xBF,
  0xFD,0x66,0xBC,0xE4,0x3A,0xEC,0x44,0x8B,0x30,0x57,0x5C,0x07,0xEC,0xFD,0xCD,0xC5,0xD1,0xCF,0x6C,0x62,
  0xA0,0x69,0xB8,0xE4,0x01,0xBB,0x13,0x7C,0x9D,0xC9,0x5C,0xB3,0x48,0xA6,0x9A,0xA7,0x80,0xB4,0x16,0xB1,
  0x5E,0x04,0x31,0xBF,0x13,0x11,0x3F,0xA2,0x0F,0x4F,0xA4,0x42,0x8B,0x30,0x39,0x52,0x51,0x98,0xF0,0x60,
  0xC8,0x90,0xB2,0xD2,0x1B,0x62,0xD1,0x99,0xCA,0x78,0x53,0x4C,0xC3,0xE8,0x76,0x9E,0xCB,0x55,0x1A,0x1F,
  0x45,0x32,0x91,0xF9,0xE8,0xBB,0xD9,0x4F,0xF8,0xFF,0x01,0x10,0xBE,0x53,0x59,0x54,0x2C,0xB8,0x98,0x2F,
  0xF4,0xE8,0x78,0x90,0xDD,0x23,0x4C,0x87,0xD3,0x84,0xEF,0x59,0x15,0xD3,0x3F,0x7F,0x2A,0xF3,0x98,0xE7,
  0x08,0x4C,0xC2,0x4C,0xF1,0x51,0x39,0xF0,0x49,0x9E,0x51,0xB8,0xD2,0x92,0xA8,0xE4,0xA3,0x54,0x2F,0x8E,
  0xA2,0x85,0x48,0x62,0x87,0xDF,0xF1,0xD4,0xDD,0x27,0x08,0xFD,0x23,0xF4,0xD8,0xD3,0x8B,0xC2,0xD0,0x1E,
  0x0D,0xB3,0xFB,0x8E,0x92,0x89,0x88,0x3B,0x25,0x53,0xCD,0xEF,0xF5,0x51,0x98,0x88,0x79,0x3A,0x4A,0xF8,
  0x4C,0xFB,0x59,0x18,0xC7,0x22,0x9D,0x8F,0x7E,0x36,0x22,0xC3,0xD2,0x68,0x95,0x2B,0x20,0x99,0x49,0x01,
  0xB6,0xCA,0xFD,0x4C,0x2A,0xB0,0x8B,0x4C,0x47,0x4A,0x8B,0xE8,0x76,0xE3,0x6B,0x99,0x8D,0x06,0x88,0x3A,
  0x13,0x3C,0x89,0xC1,0xE2,0x87,0xCD,0x72,0x1A,0xE6,0x85,0xD1,0xE7,0x15,0x9A,0xC5,0xDF,0x41,0x9E,0xE7,
  0x7C,0xE3,0x2F,0xC3,0x7C,0x2E,0x52,0x52,0xD9,0x8F,0x85,0xCA,0x92,0x70,0x33,0x4A,0x65,0xCA,0x89,0xC4,
  0xBB,0x5C,0x02,0x92,0x52,0x96,0xCE,0xA0,0xF7,0xF2,0x7B,0xDF,0x5A,0xFA,0xE4,0x31,0x92,0x3C,0x85,0xA5,
  0xE3,0xBE,0xF1,0x1F,0x8E,0x30,0x74,0x70,0x80,0x8E,0x9C,0x8C,0x23,0x8E,0xBA,0x41,0x40,0x1D,0x77,0x44,
  0x1C,0xE0,0x1C,0x7C,0x01,0xD2,0xF1,0x64,0x1C,0x8B,0x3B,0x84,0x31,0xF0,0x27,0x03,0x10,0x7C,0xE2,0xB2,
  0x99,0xCC,0x97,0x1D,0x88,0xA8,0x85,0x84,0xA9,0x77,0x57,0xD7,0x37,0x2C,0x8C,0xD0,0x2A,0x01,0xEB,0xAF,
  0xB2,0x44,0x86,0x31,0xE3,0x69,0xA4,0x37,0x19,0x04,0xDB,0x72,0x95,0x68,0x91,0x85,0xB9,0xEE,0xE3,0xA2,
  0xA3,0x38,0xD4,0xA1,0x89,0x25,0x9E,0xF0,0x48,0x13,0xED,0x99,0xBA,0xE6,0x09,0xC3,0xD8,0xC4,0x31,0x93,
  0xE9,0xD9,0x22,0x4C,0xE7,0xF0,0x71,0xF1,0x66,0xCE,0xF5,0xC5,0xB5,0xE3,0x22,0x6B,0xB3,0x60,0xF2,0x3C,
  0x9D,0xAA,0xCC,0x6F,0x3E,0xBF,0xFD,0xE6,0x2C,0xCC,0xC2,0x48,0xE8,0xCD,0xA8,0x33,0x56,0x59,0x98,0x12,
  0xD1,0x08,0x60,0xB8,0x0C,0x01,0x7B,0x17,0xBD,0x57,0x3C,0x6E,0x2E,0x58,0xC1,0xF7,0xC1,0x05,0x17,0x60,
  0xC7,0xE6,0x82,0x19,0x7C,0x1F,0x58,0x50,0xEB,0x88,0x66,0x47,0x4B,0x88,0xF4,0xC8,0xF8,0x6C,0x38,0x18,
  0x58,0x75,0x63,0x91,0x33,0xA0,0x85,0xEF,0x6D,0xBD,0xCF,0x45,0xDE,0x52,0x1C,0xE8,0xED,0x77,0x46,0x19,
  0x79,0x93,0x71,0xC2,0xE7,0x3C,0x8D,0x27,0x17,0x22,0xE1,0x9D,0x44,0x28,0x3D,0xEE,0x1B,0x08,0x62,0x51,
  0xF6,0x19,0xB9,0x6F,0x70,0x08,0x04,0x74,0x0E,0x7F,0x8B,0x8E,0x4C,0xA3,0x04,0x62,0x19,0xC8,0x42,0x4D,
  0x70,0x86,0xC4,0x53,0x2F,0x70,0xAA,0x94,0xDC,0x48,0xFD,0xCB,0x2F,0xDF,0xB3,0x1D,0x5C,0x62,0x56,0xE1,
  0xEF,0x6A,0xFA,0x23,0x84,0xE4,0xD6,0xAA,0x63,0x58,0x65,0x34,0x8D,0x1F,0x5F,0xF8,0xD3,0xCB,0x9D,0x75,
  0x27,0xB0,0xEE,0x5A,0x7C,0x36,0xDC,0xE0,0x81,0x21,0x4A,0x5A,0xED,0x37,0x0D,0x3C,0xAD,0x65,0x0E,0xD8,
  0x4E,0xA4,0xD9,0x4A,0x77,0x4C,0xA4,0x4E,0x57,0x5A,0xCB,0x94,0xDD,0x85,0xC9,0x0A,0xBE,0xDE,0xF2,0x75,
  0x07,0x5C,0x50,0xCB,0xB0,0xBC,0x35,0x1E,0x69,0xB9,0x7A,0x8B,0x84,0x5A,0x4D,0x97,0x42,0x33,0x8C,0xF4,
  0x2A,0x21,0x62,0xB9,0x4E,0x31,0x25,0x08,0x5A,0xE6,0x0C,0xF8,0xB7,0x64,0x74,0x6E,0xE7,0x6B,0x4E,0x39,
  0xD7,0xAB,0x3C,0xED,0xCC,0xC0,0xB2,0x90,0x18,0xDB,0x2C,0x0F,0x4A,0x7D,0x0E,0xB1,0xA2,0x79,0x4D,0x2A,
  0xE6,0x09,0x3A,0xE8,0xEB,0xC5,0xD6,0x61,0x0E,0xB2,0xC1,0xC2,0xE5,0xA6,0xA4,0xF9,0x3E,0xB3,0xE2,0x9D,
  0xB5,0xC4,0x83,0xD9,0xF7,0xD9,0x13,0x84,0x51,0x05,0x1B,0xE9,0x94,0xF8,0xAD,0x78,0xFA,0x71,0x80,0xB1,
  0x41,0xA9,0x97,0x11,0x22,0x55,0x26,0x14,0x02,0xFC,0x63,0x4A,0x52,0xD3,0x71,0x50,0x3A,0x59,0x5D,0x8F,
  0xCA,0x2A,0x58,0xFA,0xB2,0xF6,0xE8,0x2C,0x07,0x7E,0xB4,0xD3,0x19,0x2D,0x00,0x1B,0xDF,0x25,0xEF,0x66,
  0x3D,0xC5,0xC5,0x06,0x9F,0x2A,0x52,0x94,0x8B,0x0C,0x63,0xE5,0x2E,0xCC,0x3B,0xD7,0x32,0xBA,0xE5,0xBA,
  0xDC,0x05,0x21,0xEA,0xE2,0x60,0x16,0x26,0x8A,0x7B,0xB4,0x0D,0x80,0xEE,0x97,0xB1,0x57,0xA6,0xE9,0xD5,
  0x1D,0xCF,0x73,0x11,0x73,0x83,0xE1,0x43,0xB0,0x22,0x34,0x38,0xF1,0x70,0x74,0x26,0x93,0x60,0xE0,0x1B,
  0xA2,0xAB,0x2C,0x5D,0x7A,0xAB,0xEC,0xF2,0xDC,0x03,0xF1,0x20,0xAD,0x03,0xC6,0x60,0x46,0xE7,0x9B,0x82,
  0x2B,0x8C,0x64,0xA1,0x16,0x7F,0x41,0xB5,0xF3,0x1F,0xA2,0x50,0x47,0x0B,0x07,0xA8,0xBA,0x05,0xEC,0xBE,
  0xB9,0xC6,0x61,0x6F,0x09,0xEA,0x86,0x73,0x0E,0xD3,0xDF,0x7E,0x33,0x5B,0xA5,0x14,0x5F,0x1D,0x9E,0x5C,
  0x9E,0x3B,0x3C,0x71,0x0B,0xEB,0x95,0x58,0x46,0xAB,0x25,0xD8,0xAE,0x07,0xA2,0xBD,0x4E,0x38,0x0E,0x4F,
  0x37,0x97,0x31,0xA0,0xB4,0xD7,0xB5,0x18,0x16,0xB4,0xAF,0x6E,0xF0,0x65,0x15,0x0F,0x52,0x08,0xFF,0xBF,
  0xF8,0xD4,0x7C,0x39,0x6C,0xAD,0x46,0xFD,0x3E,0xEB,0xAE,0x45,0x0A,0xE1,0xDC,0x4B,0x64,0x14,0x22,0x95,
  0xDE,0x42,0x2A,0x8D,0x96,0xEE,0xB2,0xFE,0x5A,0x31,0xD7,0xAF,0x09,0xF4,0x64,0x2A,0x33,0x9E,0x06,0x25,
  0x43,0xD8,0xAA,0xB5,0x5B,0xFC,0x75,0x2D,0xD3,0x2B,0x00,0xD3,0xD7,0x43,0x1B,0x3D,0x4A,0xA4,0xE2,0x7B,
  0xF0,0xCF,0x10,0xBE,0x6F,0x81,0xB1,0xC7,0xBE,0x25,0x6F,0xD4,0x7C,0xDF,0x02,0x30,0xA2,0xCC,0xF7,0xA0,
  0xBF,0xCE,0xF3,0x1A,0xFD,0x69,0xDB,0x37,0xCD,0xD8,0x52,0xA8,0x10,0x33,0xE7,0x59,0x23,0x62,0xDC,0x82,
  0x22,0xE4,0x34,0x54,0x22,0x02,0xAF,0x36,0x63,0x49,0xE7,0x2B,0xEE,0x3F,0x6C,0x53,0xAA,0x55,0x2D,0xA0,
  0x6A,0xDD,0x88,0x25,0x97,0x2B,0xED,0x54,0x02,0xBB,0xDB,0x61,0xE2,0xC1,0x46,0x32,0x68,0xFB,0xB5,0xA1,
  0x3E,0xB9,0x15,0xC3,0x4E,0x05,0xF0,0xD5,0xC3,0x04,0x44,0x05,0x41,0x48,0xF5,0x61,0xF0,0x29,0x08,0x5E,
  0x14,0x2F,0x08,0xA5,0x03,0x25,0xA3,0xB3,0x54,0xF3,0xDF,0x83,0xDF,0xAF,0xAF,0xDE,0xF6,0x60,0xAF,0x06,
  0x21,0xCA,0x15,0xC6,0xA7,0x6A,0x2D,0xD0,0x28,0x88,0xD4,0x0B,0x53,0xB5,0xE6,0xB9,0x59,0x19,0x85,0x8A,
  0xB3,0x5A,0x49,0x36,0x82,0xB1,0x34,0x63,0x42,0x76,0xFD,0x69,0xCE,0xC3,0x5B,0xBF,0x8D,0x7B,0x71,0x6D,
  0x10,0x61,0xB0,0x1F,0xAB,0x4C,0x2C,0x83,0x86,0xA3,0xC7,0xF0,0x4C,0xB7,0x71,0xAD,0x43,0xBD,0x52,0x6C,
  0xB4,0xCA,0x70,0x64,0x70,0x09,0x2B,0xE6,0xB3,0x10,0xFA,0x8F,0x51,0xBD,0xEE,0x01,0x1E,0x3B,0x3E,0xAC,
  0x43,0xA0,0x68,0x4E,0x28,0xD8,0x3A,0xD1,0x24,0x8E,0x9C,0xFE,0xE3,0x16,0x98,0x20,0x36,0x94,0x70,0xC2,
  0x21,0x63,0x29,0x9D,0x43,0xBB,0x28,0x66,0x1B,0xC2,0xE9,0xB2,0x8F,0x03,0x56,0xA7,0x6F,0x15,0x40,0x8D,
  0xF0,0x69,0xD2,0x6F,0x46,0x47,0x51,0x31,0x83,0x4C,0xFE,0x77,0x05,0x8E,0x1E,0x35,0x0D,0xFB,0xD0,0xF6,
  0xF2,0xB6,0x99,0x0B,0xF2,0x2B,0x8D,0xAB,0x9C,0x9C,0x30,0x46,0xF0,0xBA,0x24,0xD0,0x09,0x21,0x68,0x21,
  0x75,0x59,0x87,0xBA,0x85,0x37,0x61,0x0A,0xF2,0xE5,0x0C,0x6D,0x64,0x6A,0x0A,0x33,0x6D,0x20,0x73,0x7B,
  0x22,0x85,0xCC,0xC1,0x73,0x47,0xD0,0xA6,0x44,0xD9,0x62,0x43,0x0C,0x8B,0x19,0x2D,0xB3,0xCD,0x1C,0x99,
  0x7F,0xBD,0xC0,0xAD,0x07,0xA6,0x7A,0x32,0x43,0xB1,0x55,0x2F,0xE1,0xE9,0x5C,0x2F,0xDC,0x02,0x61,0x39,
  0x5F,0xCA,0x3B,0xEE,0x98,0xF8,0xED,0x40,0xD9,0x77,0x90,0x90,0x80,0x62,0x29,0xC6,0x24,0x23,0xEE,0x09,
  0x6A,0x53,0x2E,0xF2,0x45,0xB7,0x6B,0xF4,0x41,0x34,0x43,0xB0,0x16,0x28,0x02,0x07,0x6B,0x6E,0x0B,0x9E,
  0xC3,0xCC,0xB4,0x91,0xC2,0xE2,0xF6,0xB0,0xD5,0x0F,0x9A,0x84,0x3F,0x88,0x4F,0x34,0x8F,0xC2,0x40,0xDB,
  0xEF,0x18,0x3C,0xB7,0x54,0xAB,0x6A,0x3E,0xFD,0x56,0xB8,0x94,0xF0,0xBD,0x2E,0xAB,0xE2,0xDB,0xB3,0x3C,
  0x46,0x2D,0xA3,0xF4,0x68,0x47,0xDD,0xE3,0x4B,0x58,0x52,0x3B,0x92,0x96,0x50,0xFF,0xDA,0x34,0xBE,0x11,
  0x3D,0xB2,0x9D,0xAE,0x5F,0xE2,0x51,0xDB,0xBA,0x8B,0x87,0xD0,0x0A,0x87,0x3A,0xD5,0x5D,0x1C,0x84,0x22,
  0x4E,0x99,0x6D,0x3B,0x9A,0x02,0xF8,0x5D,0xA8,0x17,0x4E,0x55,0x48,0xA0,0x4B,0x35,0x5E,0xA6,0x7E,0xD5,
  0xF5,0x40,0x9D,0x00,0x46,0x46,0x2D,0x5B,0x5B,0x10,0x16,0xB0,0x5E,0x0F,0x82,0xCF,0x4E,0x5B,0xEF,0x63,
  0xD1,0xB1,0x98,0x38,0x01,0x7F,0x3D,0xE8,0x3B,0x4C,0x02,0x39,0x03,0x0F,0xBF,0x93,0x50,0xE9,0xCB,0x34,
  0xE6,0xF7,0x57,0x33,0x87,0xF5,0x99,0x4B,0x86,0xAA,0x89,0x5A,0x92,0x30,0x43,0xF0,0xBA,0x0F,0x69,0xCB,
  0x5D,0x2B,0x64,0x2A,0xF2,0xF6,0x36,0xBD,0xD7,0x71,0x25,0xD2,0x41,0xCF,0x79,0xA0,0xCD,0xA8,0xB2,0xCA,
  0xC3,0x56,0x3A,0x97,0xB5,0xAA,0xF6,0xE4,0x36,0x67,0x53,0xF6,0x1F,0x31,0xA6,0x69,0xCB,0x2D,0xC8,0x7C,
  0x34,0xD3,0x08,0x90,0x76,0xD2,0x08,0x60,0xCD,0x34,0xAA,0x70,0xCD,0xEA,0x5E,0x2E,0xD7,0x25,0xEE,0x64,
  0xE8,0x16,0x16,0x1A,0x53,0x8B,0xF8,0xA7,0x5C,0x43,0xFB,0xEE,0x97,0xF9,0x9B,0x4B,0xA9,0x9F,0xCC,0x26,
  0x4F,0x80,0x38,0x84,0xDA,0x48,0x26,0x90,0x01,0xA1,0xF0,0xA2,0x24,0xC2,0x59,0xD7,0xB7,0x09,0x6D,0x92,
  0xB9,0x44,0xFB,0x1F,0x32,0x19,0xA8,0x76,0xCB,0x41,0x95,0xCF,0x30,0xDE,0xCE,0x67,0x1B,0x46,0x25,0xEA,
  0x04,0x83,0xAB,0x40,0xEE,0xB0,0xD9,0x3D,0xCD,0x1A,0x90,0x88,0x27,0x85,0xB5,0x5F,0x92,0x07,0x68,0x5D,
  0xBA,0xB6,0xCA,0x56,0x53,0x55,0xC3,0xE8,0xBE,0x2E,0x3D,0x24,0x28,0x50,0x00,0x17,0x58,0x4F,0x79,0xF7,
  0x30,0x41,0x2F,0x25,0x3E,0xE3,0x6B,0xBA,0xD1,0x5C,0xC1,0x3B,0x06,0x79,0x0C,0x93,0x47,0x7A,0x4D,0xA3,
  0x97,0x53,0xB6,0x9C,0xC1,0xD0,0xFD,0xF2,0xA5,0xFE,0x3A,0x76,0xDD,0x82,0x8E,0x4E,0x83,0x9D,0xC6,0xA5,
  0xCD,0x7F,0xE6,0x29,0x6F,0xEA,0xC5,0x55,0xA2,0x8B,0x60,0x37,0x84,0x3C,0x18,0x97,0x60,0x91,0x2A,0xD8,
  0xD8,0x90,0xC0,0xD1,0xD0,0xF5,0x22,0x9E,0x24,0x83,0x00,0xA6,0x2D,0xFC,0x0C,0xBE,0x91,0x25,0x10,0xDB,
  0x02,0x0E,0x9B,0x45,0x68,0xE6,0x6F,0xCD,0x1E,0xB7,0xF6,0x9A,0x32,0x4F,0x90,0xFA,0xC9,0x36,0xF5,0x13,
  0xB7,0x9C,0x86,0xE3,0xC6,0xA3,0x1E,0xA4,0xA3,0x88,0x89,0x1D,0x18,0xF6,0xCC,0x99,0x24,0x0F,0x63,0x21,
  0x99,0x8F,0x00,0x7B,0xE5,0x80,0x2F,0x03,0x30,0x27,0x9E,0x19,0x2E,0x20,0xA5,0x7A,0x61,0x96,0x41,0xAD,
  0x38,0xA3,0xCB,0x26,0x40,0x70,0x7D,0x03,0x86,0xEE,0xEC,0x57,0x0D,0x95,0x0B,0x0E,0x5F,0xDC,0xA1,0xA3,
  0xCD,0x11,0x2C,0x85,0xDA,0xB1,0xD4,0xBF,0xF1,0x7B,0x47,0x78,0x2F,0x5D,0xE4,0x6A,0x64,0x6F,0x28,0xA5,
  0x7C,0x82,0x3C,0xB5,0x9E,0x5A,0xB0,0x4B,0xD0,0x60,0xEA,0x7A,0xAF,0xDC,0xED,0xB2,0x5C,0x31,0x01,0xBF,
  0x98,0xE0,0x92,0x81,0xE8,0x69,0x79,0x6D,0x4A,0xE9,0xF0,0x95,0xEB,0xA9,0xE0,0xC5,0xE0,0x85,0x6F,0x8A,
  0x81,0xB4,0xFE,0x1B,0x13,0xBA,0xEC,0x82,0x10,0x0F,0xB6,0x74,0xCA,0xD6,0x46,0x44,0x91,0x92,0x56,0x31,
  0xA0,0xBD,0xDC,0x93,0x9E,0xF0,0x42,0x88,0x0C,0xB5,0x0E,0x33,0x2F,0xE6,0x4A,0xCC,0xA1,0x0A,0xDB,0xA0,
  0x4B,0x27,0x03,0xC2,0xA5,0x71,0x10,0xD8,0xB3,0x8E,0x5B,0xD8,0xE8,0xEB,0x76,0x7D,0x98,0xB0,0x1F,0x93,
  0x13,0xB7,0x0C,0xCA,0xA1,0x69,0xC3,0x38,0x44,0x6F,0xA7,0x86,0x95,0x27,0xA5,0xB4,0xCE,0xD6,0x66,0x50,
  0x5B,0xD6,0xCF,0xBF,0xBB,0x3F,0x3E,0x3D,0x7B,0xC9,0xFC,0xE6,0xEC,0x71,0x7B,0xF6,0x15,0xC9,0xA7,0xF7,
  0xD4,0xD1,0x3C,0xD0,0x14,0xCF,0x34,0xC6,0xCD,0x08,0x7D,0xA1,0x3E,0x0C,0x3F,0x35,0x1C,0xC4,0x2E,0xF0,
  0x20,0xEA,0x37,0xA6,0x8F,0x5B,0xD3,0xF6,0xDE,0xA2,0x85,0x71,0xD2,0xC2,0xC0,0x1B,0x8A,0xD2,0x44,0x56,
  0x2B,0x30,0x54,0x03,0xDD,0x02,0x1B,0x8B,0xBA,0x01,0x69,0x50,0x56,0x4D,0x09,0xF6,0x90,0x63,0x27,0xB7,
  0x7E,0x83,0x0C,0xF3,0x65,0x59,0x31,0xD1,0x11,0x75,0xEA,0x9B,0xD2,0x03,0xE8,0xA2,0x81,0x2E,0xDD,0xBA,
  0xC0,0xB6,0xCC,0x78,0x02,0xFD,0x68,0x90,0x7F,0x10,0x56,0x10,0x94,0x68,0xBE,0x3F,0x0E,0xA1,0xD1,0x46,
  0xC4,0xEE,0xF0,0x6B,0x50,0x81,0x8F,0xF5,0xA7,0x61,0xD9,0x50,0x1C,0x5C,0x57,0xF1,0xDC,0x35,0x36,0x84,
  0xEC,0x7B,0x48,0xAF,0xFC,0x2C,0x84,0xF3,0x46,0xC5,0xF2,0x2B,0x30,0x1F,0x76,0xF9,0x1C,0x57,0x7C,0x76,
  0xBD,0x56,0x53,0xDE,0x9D,0xDB,0xA5,0xB5,0x6B,0xA7,0x93,0xAF,0xB7,0xD3,0x01,0x54,0xCB,0x89,0x9E,0x54,
  0xB3,0x9F,0xB5,0xEA,0xF4,0xF3,0xE7,0x4E,0x38,0x99,0x62,0xF5,0x6E,0x80,0x09,0x3A,0x9E,0xBA,0x50,0xC6,
  0x49,0x1E,0xA8,0x0B,0x50,0xD7,0xDE,0xCA,0xB8,0xAC,0xC0,0xA7,0x1C,0x22,0x80,0x3B,0x46,0x06,0x0F,0x71,
  0x5C,0x1F,0x43,0xC4,0x9E,0x2F,0xED,0x81,0x87,0xF8,0x3D,0x43,0xB8,0x5B,0x1D,0x84,0x5A,0xDB,0x41,0x7D,
  0xD7,0x54,0xEF,0x00,0x1E,0x95,0x45,0x15,0xEC,0xB9,0x50,0x50,0xA7,0x9B,0xB7,0x30,0xE7,0x50,0xE5,0xB4,
  0xC9,0x05,0xA3,0x6B,0xBA,0xD0,0x68,0xEF,0xFD,0x88,0xB1,0xB5,0x1B,0x5A,0x79,0xCC,0x0C,0x59,0x79,0xC1,
  0xA3,0x5B,0x3C,0x2D,0x5B,0x1A,0xE5,0x4C,0xD9,0x2D,0x1A,0x99,0x1F,0xEA,0xC2,0x40,0x78,0xB6,0x21,0xCC,
  0x54,0x38,0x83,0x90,0xB0,0x05,0x8D,0x32,0xA3,0xD9,0x1C,0x92,0x1D,0xDA,0xAA,0xD2,0x8A,0xF2,0x68,0xC6,
  0xDE,0x25,0x1C,0x82,0xAA,0x63,0x6F,0x6A,0x43,0x32,0x04,0x6B,0x37,0xE8,0xF6,0x0E,0xCD,0x74,0x93,0x95,
  0xA1,0x1E,0xE9,0x22,0x4D,0x77,0xF5,0x74,0x17,0x59,0x75,0x7E,0x15,0x94,0xD4,0x1E,0x19,0xDD,0xB0,0xB5,
  0x6C,0x68,0xD0,0x12,0xC7,0xDE,0x43,0x16,0x65,0x0F,0x99,0xE5,0x72,0x99,0x69,0xA7,0xBC,0xB0,0x04,0x35,
  0x64,0xBE,0x61,0x1E,0x23,0xBF,0x90,0xE7,0x1D,0x44,0x0B,0xD2,0x55,0x92,0x7C,0xF9,0x42,0x43,0xC6,0xCA,
  0x41,0x9F,0x3D,0xA6,0xC8,0xF2,0xF6,0xAB,0xBA,0xE1,0x5D,0x3D,0x62,0xD2,0x03,0x20,0xB5,0x12,0xBB,0x6E,
  0xB0,0xD7,0x87,0x75,0xBC,0xA5,0xA6,0x60,0xDB,0xAB,0xC0,0x9A,0x58,0xB0,0xC3,0xA0,0xDC,0xF8,0xD5,0xE7,
  0xED,0x25,0xF8,0xC2,0x5A,0x45,0x5D,0x54,0xB9,0x4B,0x1D,0x0C,0x13,0x60,0x9B,0x42,0x07,0x0D,0x17,0x82,
  0x11,0x77,0xFA,0xBD,0x1F,0x3E,0x7C,0xEC,0x7F,0xFC,0xF8,0xA9,0xEF,0x75,0x5E,0xBC,0x28,0xAD,0x17,0x1B,
  0x2B,0xC5,0x26,0xB4,0xE9,0x0A,0x2F,0xD8,0x63,0x8C,0x6E,0xDC,0x05,0xB4,0x2E,0xED,0x5F,0xBB,0xF6,0xAC,
  0x6E,0x2A,0x4E,0x39,0xFC,0xB0,0xC3,0xBC,0x0C,0x0E,0x10,0x23,0xBA,0x0D,0x44,0x51,0x47,0xEA,0xF3,0x43,
  0xC9,0x4E,0x7D,0x9E,0x9C,0xE0,0xA5,0x4E,0x41,0x3C,0xAA,0x6B,0x4E,0x60,0x43,0xF7,0x97,0x3D,0xF3,0x4B,
  0x1D,0xC3,0x5F,0x7D,0x98,0x4F,0x38,0x78,0x31,0x5A,0x4D,0xDB,0xDB,0x4D,0xB8,0x16,0x4E,0xE0,0xAA,0xC2,
  0x9C,0x93,0xF0,0xC2,0x31,0x80,0x8E,0xE3,0xD2,0xDE,0x5C,0x3A,0x19,0xAC,0xB0,0x57,0x47,0x07,0x33,0x05,
  0xF1,0xF6,0x1E,0x73,0xB7,0x2F,0x5E,0x6A,0x7D,0xB6,0xCE,0xB6,0x8D,0x0B,0x19,0xF2,0xF4,0x21,0xA5,0x4C,
  0x83,0x0C,0x55,0x1E,0xAF,0x7E,0xBB,0x0C,0xD4,0x6B,0x34,0xED,0x8A,0x18,0x81,0x2B,0x7E,0x64,0xF6,0xE6,
  0x09,0xF2,0x36,0xAF,0x34,0x42,0x15,0x49,0x99,0x43,0xB6,0x7F,0x9D,0xC6,0x4D,0x49,0x0D,0xFE,0x01,0x13,
  0xD2,0x0D,0x31,0x21,0xD5,0x07,0xCA,0xBA,0x74,0x8E,0xFB,0xF6,0xBE,0x78,0xDC,0x37,0x3F,0xA2,0xF5,0xE9,
  0x47,0xD9,0xFF,0x00,0x59,0xD9,0xAF,0xA3,0xAA,0x1D,0x00,0x00
};
#endif   // embedFileman

void setupFileManager(){                  // Initialize the file manager service
  server.on("/fileman", HTTP_GET, [](AsyncWebServerRequest *request){
    if(adminAllowed(request)){
#if embedFileman
      // Note that if embedFileman is true, the FilAdminHTM setting in customize.h will be ignored!
      AsyncWebServerResponse *response = request->beginResponse_P(200, "text/html", fileman_htm_gz, sizeof(fileman_htm_gz));
      response->addHeader("Content-Encoding", "gzip");
      request->send(response);
#else
      responseWithCaching(request, FilAdminHTM);
#endif
    }
  });
  server.on("/download", HTTP_GET, [](AsyncWebServerRequest *request){    // /download is virtual. No download.htm
    if(adminAllowed(request)){
      char fsName[12];
      char fPath[256];
      char fName[256];
      int fsNum;
      bool valid;
      getParams(request,false,fsName,fPath,fName,fsNum,valid);
      if(valid){
        char filePathName[500];
        sprintf(filePathName,"%s/%s",fPath,fName);
        AsyncWebServerResponse *response = request->beginResponse(fmFS[fsNum].fileSys, filePathName, String(), true);
        response->addHeader("Server",hostname);
        request->send(response);
      }
    }
  });
  server.on("/upload", HTTP_POST, [](AsyncWebServerRequest *request){     // upload is virtual. no upload.htm
    request->send(200);
  }, handleUpload);
}

void handleUpload(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){
  if(adminAllowed(request)){
    char fsName[12];                                                      // Get the name of the file system (SD, LittleFS, ...)
    char fPath[256];                                                      // Get the directory to put this file in
    char fName[256];                                                      // Get the name of this file
    int fsNum;                                                            // Index of fsName within fmFS array
    bool valid;                                                           // Indicates if the complete path is valid
    getParams(request,true,fsName,fPath,fName,fsNum,valid);               // Get request parameters into local variables and test them
    filename.toCharArray(fName, 256);                                     // /upload doesn't have a valid fname parameter, the filename is in the filename parameter of the request
    if(valid){
      char filePathName[256];                                             // Full path and filename
      buildname(filePathName,fsName, fPath, fName, false);
      char UpdateName[275];                                               // Filesystem, path and filename (for tracking uploads)
      buildname(UpdateName,fsName, fPath, fName, true);
      if(!index){                                                         // If index (position) = 0, then first call.
        request->_tempFile = fmFS[fsNum].fileSys.open(filePathName, "w"); // Open a file and embed it within the request.
        updateUpload(UpdateName, 0, false);                               // Update with 0 bytes and not final (stat = 2/open)
      }
      if(len){                                                            // If len > 0, data is available
        request->_tempFile.write(data, len);                              // Write it into the file contained in the request
      }
      if(final){                                                          // If this is the last block
        request->_tempFile.close();                                       // close the file
      }
      updateUpload(UpdateName, index + len, final);                       // Update with total bytes and if final or not (stat = 3/writing or 4/closed)
    }
  }
}

void buildname(char filePathName[], char fsName[], char fPath[], char filename[], bool fs){
  filePathName[0] = 0;
  if(fs){strcat(filePathName, fsName);}
  strcat(filePathName,fPath);
  if(strlen(fPath) > 1){strcat(filePathName,"/");}
  strcat(filePathName,filename);
}

void getParams(AsyncWebServerRequest *request, bool post, char fsName[], char fPath[], char fName[], int &fsNum, bool &valid){
    strcpy(fsName, "");                                                      // Default file system name (for when no parameter is given)
    fsNum=-1;                                                                // File System Number, -1 means not valid
    if(request->hasParam("fs",post,false)){                                  // If a fsSel parameter was given,
      strcpy(fsName, request->getParam("fs",post,false)->value().c_str());   // set the parameter as the file system name to use
      fsNum = getFMfsNum(fsName);                                            // Find this fsName within the fmFS array
      if(fsNum<0)strcpy(fsName, "");                                         // Delete the name if it isn't valid
    }
    strcpy(fPath,"");                                                        // Default path (for when no parameter is given)
    if(request->hasParam("dir",post,false)){                                 // If a path parameter was given
      strcpy(fPath, request->getParam("dir",post,false)->value().c_str());   // get the parameter in a temporary variable
    }
    strcpy(fName,"");                                                        // Default file name (for when no parater is given)
    if(request->hasParam("fname",post,false)){                               // If a file name parameter was given
      strcpy(fName, request->getParam("fname",post,false)->value().c_str()); // get the parameter in a temporary variable
    }
    valid = (fsNum >= 0) && (fPath[0]) && (post || fName[0]);                // Valid only if fsName was found and fPath and fName were provided
    valid &= (!blockedPath(fPath));
}

// Called once when File Manager webpage initializes.
// Builds a websocket response that provides static information: Hostname and a list of available File Systems
void FMgetBasic(char rsvp[]){
  char buff[100];
  strcpy(rsvp,"{\"answer\":\"FMgetBasic\",\"hostname\":\"");
  strcat(rsvp,hostname);
  strcat(rsvp,"\",\"filesys\":[");
  for(int i = 0; i < numFS; i++){
    sprintf(buff,"\"%s\"%s",fmFS[i].name, i==numFS-1 ? "" : ",");
    strcat(rsvp,buff);
  }
  strcat(rsvp,"]}");
}

// Called when a File System is selected. Provides capacity, used, and free bytes
void FMgetFS(char rsvp[], const char* filesys){
  char pattern[] = "\"capacity\":\"%s\",\"used\":\"%s\",\"free\":\"%s\"}";
  char entry[100];
  sprintf(rsvp,"{\"answer\":\"FMgetFS\",\"filesys\":\"%s\",",filesys);
  char capa[12];
  char used[12];
  char free[12];
  int fsNum = getFMfsNum((char*)filesys);
  if(fsNum>=0){
    bytes(capa, fsBytes(fmFS[fsNum].name,1));
    bytes(used, fsBytes(fmFS[fsNum].name,2));
    bytes(free, fsBytes(fmFS[fsNum].name,3));
    sprintf(entry,pattern,
      capa,                           // Total capacity of file system in human convenient form (15.12GB, etc.)
      used,                           // Bytes used on file system in human convenient form (127.12MB, etc.)
      free);                          // Bytes free on file system in human convenient form (15GB, etc.)
    strcat(rsvp, entry);              // Add this file system entry into the String FSInfo
  } else {rsvp[0]=0;}                 // Remove data if file system was not valid
}

int getFMfsNum(char filesys[]){
  int retVal = -1;
  for(int i = 0; i<numFS; i++){
    if(strcmp(fmFS[i].name, filesys)==0){
     retVal = i;
     break;
    }
  }
  return retVal;  
}
void bytes(char buff[], uint64_t b){
  const uint64_t k = 1024;                              // one kilo (as applies to bytes!)
  uint64_t c = 1024;                                    // Comparator
  float d = 1.0;                                        // Divisor
  char label[5][3] = {"B","KB","MB","GB","TB"};
  for(int i = 0; i < 5; i++){
    if(b < c){
      sprintf(buff, "%.2f", ((float)b / d));            // Fill buff with number with two decimals
      while(strlen(buff)>1 &&
      (buff[strlen(buff)-1] == '0' || 
       buff[strlen(buff)-1] == '.')){
        buff[strlen(buff)-1]=0;                         // Remove trailing zeros or decimal points
      }
      strcat(buff,label[i]);                            // Add the designator in (B, KB, etc.)
      break;
    }
    c *= k;
    d *= k;
  }
}

// Can't get byte sizes from a file system, must be explicitly a super class of file system like SD or LitteFS
// So, this helper routine (aka. code cludge!) gets byte information from a file system name like "SD" or "LittleFS"
uint64_t fsBytes(char fsName[],int x){
  uint64_t bytes;
#if(UseLittleFS)
  if(strcmp(fsName,"LittleFS") == 0){
    switch(x){
      case 1: bytes = LittleFS.totalBytes(); break; 
      case 2: bytes = LittleFS.usedBytes(); break; 
      case 3: bytes = LittleFS.totalBytes()-LittleFS.usedBytes(); break; 
    }
    return bytes;
  }
#endif
#if((SDType == TypeSD || SDType == TypeMMC))
  if(strcmp(fsName,"SD") == 0){
    switch(x){
      case 1: bytes = SD.totalBytes(); break; 
      case 2: bytes = SD.usedBytes(); break; 
      case 3: bytes = SD.totalBytes()-SD.usedBytes(); break; 
    }
    return bytes;
  }
#endif
  return 0;
}

bool blockedPath(char path[]){
  if(strlen(FMblockedPath)==0) return false;
  String Dir  = path;
  Dir.concat("/");
  Dir.replace("//","/");
  bool block = Dir.startsWith(FMblockedPath);
  return block;
}

// Called when a directory is selected in File Manager
// Provides a list of directories and a list of files in the path
// The String can get very large if there are lots of directories or files and especially when using long file names!
String FMgetDir(const char* filesys, const char* dir){
  int fs = -1;
  char buff[400];                                    // Buffer to put single directory entries in JSON format into
  if(blockedPath((char *)dir)) return "";
  for(int i = 0; i < numFS; i++){                    // Find the right file System
    if(strcmp(fmFS[i].name, filesys)==0){
      fs = i;
      break;
    }
  }
  if(fs==-1) return "";

  File root = fmFS[fs].fileSys.open(dir);            // Try to open the requested directory using the requested file system.
                                                     // (May not be root, but some path. For our purposes, it is the beginning, so... root)
  if(!root) return "";
  String json = "";
  String paths = "";                                 // String to contain JSON... May be EXTREMELY long if lots of directories and/or deep paths
  char buffB[12];                                    // Buffer to contain file sizes
  sprintf(buff, "{\"answer\":\"FMgetDir\",\"filesys\":\"%s\",\"dir\":\"%s\",\"dirs\":[",filesys,dir);
  paths += buff;
  File file = root.openNextFile();                   // file to use to loop through the path looking for directories
  // First pass through directory collects only directory data.
  // Making two passes may seem inefficient but I am hoping to fragment memory less by
  // not growing two potentially very large strings simultaneously.
  char header[2] = {0,0};
  while(file){                                       // As long as files (or directories) keep coming
    if(file.isDirectory()){
      if(!strcmp(file.name(), "System Volume Information")==0){
        sprintf(buff,"%s/%s", dir, file.name());
        if(!blockedPath(buff)){
          sprintf(buff, "%s\"%s\"",header,file.name());
          paths += buff;
          header[0]=',';                        // Future data elements will be prefaced with ","
        }
      }
    }
    file = root.openNextFile();
  }
  json += paths + "],\"files\":[";
  paths = "";
  root.rewindDirectory();
  header[0] = 0;
  file = root.openNextFile();                   // file to use to loop through the path looking for directories
  // Second pass through directory collects only file data.
  while(file){                                  // As long as files (or directories) keep coming
    if(!file.isDirectory()){
      bytes(buffB,file.size());                 // Format the file size into buffB (1.18KB or 2.34MB or 1.01GB for example)
      char dt[20];                              // buffer for date/time file was last written to
      time_t t = file.getLastWrite();           // Date/Time the file was last written to
      strftime(dt, 20, "%Y/%m/%d %H:%M:%S", localtime(&t));
      sprintf(buff, "%s{\"file\":\"%s\",\"date\":\"%s\",\"size\":\"%s\",\"bytes\":\"%d\"}",header,file.name(),dt,buffB,file.size());
      header[0]=',';
      paths += buff;
    }
    file = root.openNextFile();
  }
  json += paths + "]}";
  return json;
}

String getFilesInfo(char fsName[], char path[]){
  if(fsName =="" || path == "") return "";
  int fs = -1;
  for(int i = 0; i < numFS; i++){
    if(fmFS[i].name == fsName){
      fs = i;
      break;
    }
  }
  if(fs==-1) return "";
  File root = fmFS[fs].fileSys.open(path);           // Try to open the requested directory using the requested file system.
                                                     // (May not be root, but some path. For our purposes, it is the beginning, so... root)
  if(!root) return "";
  String files = "{";                                // String to contail all file entries... May be EXTREMELY long if lots of files and/or long file names
  char buff[300];                                    // Buffer to put file entries in JSON format into
  File file = root.openNextFile();                   // file to use to loop through the path looking for directories
  char header[2] = {0,0};
  char buffB[12];
  while(file){                                       // As long as files (or directories) keep coming
    if(!file.isDirectory()){
      bytes(buffB,file.size());
      sprintf(buff, "%s{\"file\",\"%s\";\"size\":\"%s\"}",header,file.name(),buffB);
      header[0]=',';
      files += buff;
    }
    file = root.openNextFile();
  }
  files += "}";                                        // Add closing brace
}

void FMdelete(int fsNum, char fullPath[]){             // Delete a file as requested by file manager websocket request
  if(!blockedPath(fullPath)){
    if(fsNum >= 0)
      fmFS[fsNum].fileSys.remove(fullPath);
  }
}

void FMmkDir(int fsNum, const char *path, const char *newDir){
  if(fsNum >= 0){
    if(fmFS[fsNum].fileSys.exists(path)){
      char buff[400];
      sprintf(buff,"%s/%s",path,newDir);
      if((!blockedPath(buff)) && (!fmFS[fsNum].fileSys.exists(buff)))
        fmFS[fsNum].fileSys.mkdir(buff);
    }
  }
}

// Variables used in File Manager to keep track of uploads in progress.
// This is done because there is normally no way for the server to tell the client
// how far the upload has progressed, and the client also has no way of knowing how far
// it has progressed. If we had PHP we could do it, but we don't, so...
// we use websocket messages
// Structure  FMupload has data to keep track of uploads in progress
typedef struct {char path[256];                        // Unique. You can't upload the same file more than once simultaneously!
                int stat;                              // 0=Empty, 1=Initializing, 2=Open, 3=Writing/Uploading, 4=Closed
                unsigned long filesize;                // Size of the file as reported by the client
                unsigned long written;                 // Bytes written to the file thus far (index + len)
                unsigned long started;                 // millis() when transfer began
                unsigned long stopped;                  // millis() when transfer finished
               } FMupload;

// Array FMuploads can hold up to 5 active uploads. If we actually had 5 simultaneously, the server
// would definitely be under STRESS
FMupload FMuploads[]={{"",0,0,0},{"",0,0,0},{"",0,0,0},{"",0,0,0},{"",0,0,0}};
const int numFMuploads = sizeof(FMuploads) / sizeof(FMupload);

bool findUpload(char path[], int &w, int &e, bool shortcut){ // Each path is (should be!) unique, find this one
  int i;
  bool found = false;                                   // It has not been found yet
  e = -1;                                               // Haven't found an empty slot yet
  for(i = 0; i<numFMuploads; i++){                      // Loop through all entries in the FMuploads array
    if(FMuploads[i].stat > 0){                          // If this slot contains an entry
      if(strcmp(path, FMuploads[i].path)==0){           // Is it the one we are looking for
        found=true;
        break;
      }
    }
    else if(e==-1){e=i;if(shortcut)break;}              // If this is the first empty slot, remember it
  }
  w = found ? i : e;                                    // Tell the caller where (if) the entry was found or an empty slot is available
  return found;
}

int createUpload(char path[], unsigned long sz){       // Creata an entry in the FMuploads array
  int here=-1, firstEmpty;                             // Variables for where this entry is in array, or first available empty slot
  if(findUpload(path, here, firstEmpty, true) < 0){    // Each path is (should be!) unique, find this one
    if(firstEmpty>=0) here=firstEmpty;                 // If not found (shouldn't), use the first empty slot
  }
  if(here == -1){                                      // If no empty slot is available for creation 
    unsigned long oldest = 0;                          // find the oldest closed slot available and use it
    for(int i = 0; i<numFMuploads; i++){               // Loop through all entries in the FMuploads array
      if(FMuploads[i].stat == 4){                      // If this slot contains an entry that is closed
        if(millis() - FMuploads[i].stopped > oldest){  // Is it older than what we have found so far?
          oldest = millis() - FMuploads[i].stopped;    // Remember how old it is for further comparisons
          here = i;
        }
      }
    }
  }
  if(here>=0){                                         // If the path was found, or an empty slot was available
    strcpy(FMuploads[here].path, path);                // Copy this path into the upload structure
    FMuploads[here].stat = 1;                          // Set the status to 1/Initializing
    FMuploads[here].filesize = sz;                     // Set the expected filesize
    FMuploads[here].written = 0;                       // So far, zero bytes have been written
    FMuploads[here].started = 0;                       // It hasn't started
    FMuploads[here].stopped = 0;                       // It hasn't stopped
  }
  return here;
}

int updateUpload(char path[], unsigned long bytes, bool final){  // Update this entry in the FMuploads array
  int here=-1, firstEmpty;                                 // Variables for where this entry is in array, or first available empty slot
  findUpload(path, here, firstEmpty,false);             // Each path is (should be!) unique, find this one
  if(here>=0){                                          // If the path was found
    if(bytes == 0){
      FMuploads[here].stat = 2;                         // Set status to 2/Open
      FMuploads[here].started = millis();               // Record time when download began
    } else FMuploads[here].stat = final ? 4 : 3;        // Set status to 4/Closed or 3/Writing
    FMuploads[here].written = bytes;
    if(final)FMuploads[here].stopped = millis();        // Record time when download was completed
  }
  return here;
}

void deleteUpload(char path[]){                         // Delete this entry from FMuploads array
  int here, firstEmpty;                                 // Variables for where this entry is in array, or first available empty slot
  findUpload(path, here, firstEmpty, false);            // Each path is (should be!) unique, find this one
  if(here>=0){                                          // If the path was found
    FMuploads[here].path[0] = 0;                        // Delete the path in the upload structure
    FMuploads[here].stat = 0;                           // Reset the status to 0/Empty
    FMuploads[here].filesize = 0;                       // Reset the expected filesize to 0
    FMuploads[here].written = 0;                        // Reset bytes written to 0
  }
}

void statusUpload(char path[], char stat[]){            // Build up a websocket response to a request for upload status
  int here, firstEmpty;                                 // Variables for where this entry is in array, or first available empty slot
  findUpload(path, here, firstEmpty, false);            // Each path is (should be!) unique, find this one
  strcpy(stat,"");                                      // Start with a clean buffer
  if(here>=0){                                          // If the path was found
    unsigned long pct = 0;
    if(FMuploads[here].stat > 2){                       // Only calculate a percentage of completion if at least writing
      if(FMuploads[here].filesize > 0){                 // Can't divide by zero, but filesizes can be zero. Avoid division by zero error!
        float f = ((float) FMuploads[here].written) / ((float) FMuploads[here].filesize);
        f *= 100.0;
        pct = f;
      } else pct = 100;                                 // Files with zero length are 100% transferred.
    }
    unsigned long t = (FMuploads[here].stat == 4 ? FMuploads[here].stopped : millis()) - FMuploads[here].started;
    sprintf(stat,"{\"answer\":\"FMuploadStatus\",\"bytes\":\"%u\",\"size\":\"%u\",\"percent\":\"%u\",\"status\":\"%i\",\"time\":\"%u\"}",
       FMuploads[here].written, FMuploads[here].filesize, pct, FMuploads[here].stat, t);
  }
}
#endif   // useFileManager
